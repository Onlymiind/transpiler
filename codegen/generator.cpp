#include "codegen/generator.h"
#include "common/ast.h"
#include "common/base_classes.h"
#include "common/declarations.h"
#include "common/expression.h"
#include "common/literals.h"
#include "common/module.h"
#include "common/statement.h"
#include "common/types.h"
#include "common/util.h"
#include "vm/vm.h"

#include <algorithm>
#include <bit>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <vector>

namespace codegen {

    Generator::Generator(common::Global &&global, common::Module &mod,
                         common::AST &ast, common::Identifiers &&identifiers)
        : program_{std::move(identifiers),
                   common::TypeStorage{std::move(global)}},
          mod_(&mod), ast_(&ast) {

        program_.types.import(mod);
        const auto &types = program_.types.types();
        uint64_t idx = 0;
        for (const auto &type : types) {
            type_to_idx_[type.get()] = idx;
            ++idx;
        }

        program_.cap_name = program_.identifiers.add("cap");
        program_.size_name = program_.identifiers.add("len");
        program_.data_name = program_.identifiers.add("data");

        append_name_ = program_.identifiers.add("append");
    }

    bool Generator::codegen() {

        if (!generate_pointer_maps()) {
            return false;
        }

        // generate function IDs
        for (const auto [name, funcID] : mod_->functions()) {
            const common::Function &func = *ast_->get_function(funcID);
            if (func.decl_only && !func.is_native) {
                continue;
            }

            func_to_idx_[funcID] = func.is_native
                                       ? program_.native_functions.size()
                                       : program_.functions.size();

            func_ids_.push_back(funcID);

            std::vector<const common::Type *> args{func.params.size()};
            std::transform(func.params.begin(), func.params.end(), args.begin(),
                           [this](common::VariableID param) {
                               return ast_->get_var(param)->type;
                           });

            if (!func.is_native) {
                program_.functions.emplace_back(
                    vm::Function{.name = *program_.identifiers.get(name),
                                 .args = std::move(args)});
            } else {
                program_.native_functions.emplace_back(
                    vm::NativeFunction{.name = *program_.identifiers.get(name),
                                       .args = std::move(args),
                                       .return_type = func.return_type});
            }
        }

        // generate global initialization code
        // first, allocate all global variables
        size_t current_idx = 0;
        for (const auto varID : ast_->global_variables()) {
            var_to_idx_[varID] = current_idx;
            ++current_idx;

            if (!push_allocate(ast_->get_var(varID)->type)) {
                return false;
            }
        }

        // second, generate initialization code
        // (has to be done AFTER generating function IDs)
        const auto &global_vars = ast_->global_variables();
        program_.global_count = global_vars.size();
        for (const auto varID : global_vars) {
            const common::Variable &var = *ast_->get_var(varID);
            if (!var.initial_value) {
                continue;
            }

            if (!codegen_expression(*var.initial_value)) {
                return false;
            }
            push_assign(var.type);
        }

        // copy the generated bytecode to initialization function
        // note that it doesn't return
        program_.functions.emplace_back(
            vm::Function{.name = std::string{vm::VM::global_init_name},
                         .code = std::move(output_)});

        // now generate all the functions
        for (const auto funcID : func_ids_) {
            const common::Function &func = *ast_->get_function(funcID);
            if (func.decl_only) {
                continue;
            }
            if (!codegen_function(func)) {
                return false;
            }
        }

        return true;
    }

    bool Generator::generate_pointer_maps() {
        const auto &types = program_.types.types();
        program_.type_infos.reserve(types.size());

        for (const auto &type : types) {
            generate_pointer_map(type.get());
        }

        for (const auto &type : types) {
            program_.type_infos.emplace_back(std::make_unique<vm::TypeInfo>(
                std::move(type_to_info_.at(type.get()))));
        }

        return true;
    }

    const vm::TypeInfo &
    Generator::generate_pointer_map(const common::Type *type) {
        if (type_to_info_.contains(type)) {
            return type_to_info_.at(type);
        }

        vm::TypeInfo info{.description = type};
        if (type->alignment() < common::g_pointer_size) {
            return type_to_info_.emplace(type, std::move(info)).first->second;
        }

        if (type->is_primitive()) {
            info.is_ptr.push_back(false);
        } else if (type->is_pointer()) {
            info.is_ptr.push_back(true);
        } else if (type->kind() == common::TypeKind::ARRAY) {
            const common::ArrayType
                *array = dynamic_cast<const common::ArrayType *>(type);

            const vm::TypeInfo &element = generate_pointer_map(
                array->element_type());

            for (size_t i = 0; i < array->count(); ++i) {
                info.is_ptr.insert(info.is_ptr.end(), element.is_ptr.begin(),
                                   element.is_ptr.end());
            }
        } else if (type->kind() == common::TypeKind::STRUCT) {
            const common::StructType
                *record = dynamic_cast<const common::StructType *>(type);

            size_t last_offset = 0;
            for (const auto &field : record->fields()) {
                if (field.type->alignment() < common::g_pointer_size) {
                    continue;
                }

                for (; last_offset < field.offset; ++last_offset) {
                    info.is_ptr.push_back(false);
                }
                last_offset = field.offset;

                const vm::TypeInfo &field_info = generate_pointer_map(
                    field.type);
                info.is_ptr.insert(info.is_ptr.end(), field_info.is_ptr.begin(),
                                   field_info.is_ptr.end());
            }
            for (; last_offset < record->size(); ++last_offset) {
                info.is_ptr.push_back(false);
            }
        }

        return type_to_info_.emplace(type, std::move(info)).first->second;
    }

    bool Generator::codegen_expression(const common::Expression &expr,
                                       bool want_ptr) {
        if (expr.is_error()) {
            return false;
        }

        switch (expr.kind()) {
        case common::ExpressionKind::BINARY:
            return codegen_binary(
                dynamic_cast<const common::BinaryExpression &>(expr));
        case common::ExpressionKind::UNARY:
            return codegen_unary(dynamic_cast<const common::UnaryExpression &>(
                                     expr),
                                 want_ptr);
        case common::ExpressionKind::LITERAL:
            return codegen_literal(dynamic_cast<const common::Literal &>(expr));
        case common::ExpressionKind::CAST:
            return codegen_cast(dynamic_cast<const common::Cast &>(expr));
        case common::ExpressionKind::FUNCTION_CALL:
            return codegen_call(
                dynamic_cast<const common::FunctionCall &>(expr));
        case common::ExpressionKind::VARIABLE_REF:
            return codegen_var_ref(dynamic_cast<
                                       const common::VariableReference &>(expr),
                                   want_ptr);
        case common::ExpressionKind::INDEX:
            return codegen_index_expression(dynamic_cast<
                                                const common::IndexExpression
                                                    &>(expr),
                                            want_ptr);
        case common::ExpressionKind::MEMBER_ACCESS:
            return codegen_member_access(dynamic_cast<const common::MemberAccess
                                                          &>(expr),
                                         want_ptr);
        default: report_error("unknown expression type"); return false;
        }
    }

    bool Generator::codegen_literal(const common::Literal &lit) {
        uint64_t value = 0;
        if (const bool *b = lit.get<bool>(); b) {
            value = *b ? vm::VM::true_value : vm::VM::false_value;
        } else if (const int64_t *integer = lit.get<int64_t>(); integer) {
            value = static_cast<uint64_t>(*integer);
        } else if (const double *d = lit.get<double>(); d) {
            value = std::bit_cast<uint64_t>(*d);
        } else if (lit.is<std::nullptr_t>()) {
            value = vm::VM::null_value;
        } else if (const char *c = lit.get<char>(); c) {
            value = static_cast<uint64_t>(*c);
        } else {
            report_error("unknown literal type");
            return false;
        }

        push_op(vm::Op::PUSH, value);
        return true;
    }

    void Generator::push_arithmetic_op(const common::Type *type, vm::Op int_op,
                                       vm::Op float_op) {
        if (type->has_trait(common::TypeTraits::INTEGER)) {
            push_op(int_op, vm::needs_truncation(int_op) ? type->size() : 0);
        } else {
            push_op(float_op);
        }
    }

    bool Generator::codegen_unary(const common::UnaryExpression &expr,
                                  bool want_ptr) {
        using enum common::UnaryOp;
        if (!codegen_expression(*expr.expression(), expr.op() == ADDRESS_OF)) {
            return false;
        }

        switch (expr.op()) {
        case INVERT: push_op(vm::Op::INV, expr.type()->size()); break;
        case NOT: push_op(vm::Op::NOT); break;
        case NEGATE:
            push_arithmetic_op(expr.type(), vm::Op::NEGATE_I, vm::Op::NEGATE_F);
            break;
        case ADDRESS_OF: break;
        case DEREFERENCE: {
            push_op(vm::Op::ASSERT_NOT_NULL);
            if (want_ptr) {
                break;
            }

            const common::PointerType
                *typ = dynamic_cast<const common::PointerType *>(
                    expr.expression()->type());
            push_read(typ->pointee_type());
            break;
        }
        default: report_error("unknown unary operator"); return false;
        }

        return true;
    }

    void Generator::push_equals(const common::Type *type) {
        if (type->is_pointer() || type->is_primitive()) {
            push_op(vm::Op::EQUALS);
        } else {
            push_op(vm::Op::MEM_EQUALS);
        }
    }

    void Generator::push_assign(const common::Type *type) {
        if (type->is_pointer() || type->is_primitive()) {
            push_op(vm::Op::WRITE, type->size());
        } else {
            push_op(vm::Op::COPY, type->size());
        }
    }

    bool Generator::codegen_binary(const common::BinaryExpression &expr) {
        using enum common::BinaryOp;
        if (!codegen_expression(*expr.lhs(), expr.op() == ASSIGN)) {
            return false;
        } else if (!codegen_expression(*expr.rhs())) {
            return false;
        }

        switch (expr.op()) {
        case ADD:
            push_arithmetic_op(expr.type(), vm::Op::ADD_I, vm::Op::ADD_F);
            break;
        case SUB:
            push_arithmetic_op(expr.type(), vm::Op::SUB_I, vm::Op::SUB_F);
            break;
        case MUL:
            push_arithmetic_op(expr.type(), vm::Op::MUL_I, vm::Op::MUL_F);
            break;
        case DIV:
            push_arithmetic_op(expr.type(), vm::Op::DIV_I, vm::Op::DIV_F);
            break;
        case REMAINDER: push_op(vm::Op::REM); break;
        case AND: push_op(vm::Op::BITWISE_AND); break;
        case OR: push_op(vm::Op::BITWISE_OR); break;
        case EQUALS: push_equals(expr.lhs()->type()); break;
        case NOT_EQUALS:
            push_equals(expr.lhs()->type());
            push_op(vm::Op::NOT);
            break;
        case LESS:
            push_arithmetic_op(expr.lhs()->type(), vm::Op::LESS_I,
                               vm::Op::LESS_F);
            break;
        case GREATER:
            push_arithmetic_op(expr.lhs()->type(), vm::Op::GREATER_I,
                               vm::Op::GREATER_F);
            break;
        case LESS_EQUALS:
            push_arithmetic_op(expr.lhs()->type(), vm::Op::GREATER_I,
                               vm::Op::GREATER_F);
            push_op(vm::Op::NOT);
            break;
        case GREATER_EQUALS:
            push_arithmetic_op(expr.lhs()->type(), vm::Op::LESS_I,
                               vm::Op::LESS_F);
            push_op(vm::Op::NOT);
            break;
        case ASSIGN: push_assign(expr.lhs()->type()); break;
        case BITWISE_AND: push_op(vm::Op::BITWISE_AND); break;
        case BITWISE_OR: push_op(vm::Op::BITWISE_OR); break;
        case SLA: push_op(vm::Op::SLA, expr.type()->size()); break;
        case SRA: push_op(vm::Op::SRA); break;
        case SRL: push_op(vm::Op::SRL); break;
        case XOR: push_op(vm::Op::XOR); break;
        default: report_error("unlnown binary operator"); return false;
        }
        return true;
    }

    void Generator::push_truncate(size_t bytes) {
        if (bytes >= sizeof(uint64_t)) {
            return;
        }

        uint64_t mask = static_cast<uint64_t>(-1);
        for (size_t i = 0; i < bytes; ++i) {
            mask <<= 8;
        }
        push_op(vm::Op::PUSH, ~mask);
        push_op(vm::Op::BITWISE_AND);
    }

    bool Generator::codegen_cast(const common::Cast &cast) {
        if (cast.type() == cast.from()->type() || cast.type()->is_pointer()) {
            return true;
        } else if (cast.type()->has_trait(common::TypeTraits::INTEGER) &&
                   cast.from()->type()->has_trait(
                       common::TypeTraits::INTEGER)) {
            size_t to_size = cast.type()->size();
            size_t from_size = cast.from()->type()->size();
            if (to_size >= from_size) {
                return true;
            }
            push_truncate(to_size);
            return true;
        }

        push_arithmetic_op(cast.type(), vm::Op::TO_INTEGER, vm::Op::TO_FLOAT);
        return true;
    }

    bool Generator::codegen_function(const common::Function &func) {
        if (func.decl_only || func.is_native) {
            report_error("attempting to generate function without a body");
            return false;
        }
        local_idx_ = 0;

        for (const auto &arg : func.params) {
            var_to_idx_[arg] = local_idx_;
            ++local_idx_;
        }

        if (!codegen_block(func.body)) {
            return false;
        }
        if (!func.return_type) {
            // implicit `return` at the end of a function without return type
            push_op(vm::Op::RETURN);
        }

        program_.functions[func_to_idx_.at(func.id)].code = std::move(output_);
        return true;
    }

    bool Generator::codegen_call(const common::FunctionCall &call) {
        const auto &args = call.arguments();

        if (call.name() == append_name_) {
            if (!codegen_expression(*args[0])) {
                return false;
            }

            for (size_t i = 1; i < args.size(); ++i) {
                if (!codegen_expression(*args[i])) {
                    return false;
                }

                push_op(vm::Op::APPEND, type_to_idx_.at(args[i]->type()));
            }
            return true;
        }

        for (const auto &arg : args) {
            if (!push_allocate(arg->type())) {
                return false;
            }
            push_op(vm::Op::DUP);
            if (!codegen_expression(*arg)) {
                return false;
            }
            push_assign(arg->type());
        }

        const common::Function &func = *ast_->get_function(call.id());
        uint64_t idx = func_to_idx_.at(call.id());
        if (func.is_native) {
            push_op(vm::Op::NATIVE_CALL, idx);
        } else {
            push_op(vm::Op::CALL, idx);
        }
        return false;
    }

    bool Generator::push_allocate(const common::Type *type) {

        if (type->kind() == common::TypeKind::ARRAY) {
            const common::ArrayType
                *arr = dynamic_cast<const common::ArrayType *>(type);
            uint64_t type_idx = type_to_idx_.at(arr->element_type());
            push_op(vm::Op::PUSH, arr->count());
            push_op(vm::Op::ALLOCATE_ARRAY, type_idx);
        } else {
            uint64_t type_idx = type_to_idx_.at(type);
            push_op(vm::Op::ALLOCATE, type_idx);
        }

        return true;
    }

    bool Generator::codegen_var(const common::Variable &var) {
        var_to_idx_[var.id] = local_idx_;
        ++local_idx_;

        if (!push_allocate(var.type)) {
            return false;
        }

        if (var.initial_value) {
            push_op(vm::Op::DUP);
            if (!codegen_expression(*var.initial_value)) {
                return false;
            }
            push_assign(var.type);
        }

        return true;
    }

    bool Generator::codegen_branch(const common::Branch &branch) {
        if (!codegen_expression(*branch.predicate())) {
            return false;
        }

        push_op(vm::Op::NOT);
        vm::Instruction &false_branch = push_op(vm::Op::BRANCH);

        if (!codegen_block(branch.true_branch())) {
            return false;
        }

        vm::Instruction *end = nullptr;

        if (branch.false_branch()) {
            end = &push_op(vm::Op::JUMP);
        }

        false_branch.arg = output_.size();

        if (branch.false_branch()) {
            if (!codegen_block(*branch.false_branch())) {
                return false;
            }
            end->arg = output_.size();
        }

        return true;
    }

    bool Generator::codegen_block(const common::Block &block) {
        if (!block.reachable()) {
            return true;
        }

        for (const auto &stmt : block.statements()) {
            if (!stmt->reachable()) {
                break;
            }

            if (!codegen_statement(*stmt)) {
                return false;
            }
        }

        return true;
    }

    bool Generator::codegen_loop(const common::Loop &loop) {
        if (loop.init()) {
            if (!codegen_statement(*loop.init())) {
                return false;
            }
        }

        break_jumps_.push_back(std::vector<vm::Instruction *>{});
        continue_jumps_.push_back(std::vector<vm::Instruction *>{});
        uint64_t start = output_.size();
        if (loop.condition()) {
            if (!codegen_expression(*loop.condition())) {
                return false;
            }
            push_op(vm::Op::NOT);

            break_jumps_.back().push_back(&push_op(vm::Op::BRANCH));
        }

        if (!codegen_block(loop.body())) {
            return false;
        }

        for (auto jump : continue_jumps_.back()) {
            jump->arg = output_.size();
        }
        continue_jumps_.pop_back();

        if (loop.iteration()) {
            if (!codegen_expression(*loop.iteration())) {
                return false;
            }
        }

        push_op(vm::Op::JUMP, start);
        for (auto jump : break_jumps_.back()) {
            jump->arg = output_.size();
        }
        break_jumps_.pop_back();
        return true;
    }

    bool Generator::codegen_statement(const common::Statement &smt) {
        switch (smt.kind()) {
        case common::StatementType::RETURN: {
            const common::Return &ret = dynamic_cast<const common::Return &>(
                smt);
            if (ret.expression()) {
                if (!codegen_expression(*ret.expression())) {
                    return false;
                }

                push_op(vm::Op::RETURN, 1);
            } else {
                push_op(vm::Op::RETURN);
            }
            break;
        }
        case common::StatementType::EXPRESSION: {
            const common::Expression
                *expr = dynamic_cast<const common::ExpressionStatement &>(smt)
                            .expression();
            codegen_expression(*expr);
            if (expr->type()) {
                push_op(vm::Op::POP);
            }
            break;
        }
        case common::StatementType::VARIABLE:
            return codegen_var(*ast_->get_var(
                dynamic_cast<const common::VariableDeclatarion &>(smt)
                    .variable()));
        case common::StatementType::BRANCH:
            return codegen_branch(dynamic_cast<const common::Branch &>(smt));
            break;
        case common::StatementType::LOOP:
            return codegen_loop(dynamic_cast<const common::Loop &>(smt));
            break;
        case common::StatementType::BREAK:
            break_jumps_.back().push_back(&push_op(vm::Op::JUMP));
            break;
        case common::StatementType::CONTINUE:
            continue_jumps_.back().push_back(&push_op(vm::Op::JUMP));
            break;
        default: report_error("statement type not supported"); return false;
        }

        return true;
    }

    bool
    Generator::codegen_index_expression(const common::IndexExpression &expr,
                                        bool want_ptr) {
        if (!codegen_expression(*expr.container())) {
            return false;
        }

        const common::Type *type = expr.container()->type();
        const common::Type *element_type = nullptr;
        if (type->kind() == common::TypeKind::ARRAY) {
            const common::ArrayType
                *array = dynamic_cast<const common::ArrayType *>(type);
            element_type = array->element_type();
            push_op(vm::Op::PUSH, array->count());
        } else {
            const common::StructType
                *slice = dynamic_cast<const common::StructType *>(type);
            const auto *size_field = slice->get_field(program_.size_name);
            const auto *data_field = slice->get_field(program_.data_name);
            element_type = dynamic_cast<const common::PointerType *>(
                               data_field->type)
                               ->pointee_type();

            // get pointer to data
            push_op(vm::Op::DUP);
            push_op(vm::Op::PUSH, data_field->offset);
            push_op(vm::Op::ADD_I, data_field->type->size());
            push_read(data_field->type);

            // get size
            push_op(vm::Op::SWAP);
            push_op(vm::Op::PUSH, size_field->offset);
            push_op(vm::Op::ADD_I, size_field->type->size());
            push_read(size_field->type);
        }
        if (!codegen_expression(*expr.index())) {
            return false;
        }
        push_op(vm::Op::INDEX_ARRAY, element_type->size());
        if (!want_ptr) {
            push_read(expr.type());
        }
        return true;
    }

    bool Generator::codegen_var_ref(const common::VariableReference &ref,
                                    bool want_ptr) {
        const common::Variable &var = *ast_->get_var(ref.id());

        if (!var_to_idx_.contains(var.id)) {
            return false;
        }

        uint64_t idx = var_to_idx_.at(var.id);

        if (var.is_gloabl) {
            push_op(vm::Op::GET_GLOBAL, idx);
        } else {
            push_op(vm::Op::GET_LOCAL, idx);
        }

        if (!want_ptr) {
            push_read(var.type);
        }

        return true;
    }

    void Generator::push_read(const common::Type *type) {
        if (!(type->is_primitive() || type->is_pointer())) {
            return;
        }

        uint64_t arg = type->size();
        if (type->is_pointer()) {
            arg |= vm::VM::read_is_ptr_mask;
        }

        push_op(vm::Op::READ, arg);
    }

    bool Generator::codegen_member_access(const common::MemberAccess &access,
                                          bool want_ptr) {
        if (!codegen_expression(*access.record())) {
            return false;
        }

        const common::StructType
            &type = *dynamic_cast<const common::StructType *>(
                access.record()->type());
        const common::Field &field = *type.get_field(access.member_name());

        push_op(vm::Op::PUSH, field.offset);
        push_op(vm::Op::ADD_I, 8);

        if (!want_ptr) {
            push_read(access.type());
        }

        return true;
    }

} // namespace codegen
